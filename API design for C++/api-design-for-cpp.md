# 第1章 はじめに

# 第2章 優れたAPIの特徴
内部実装が隠蔽されていて,使い方がわかりやすく,疎結合であること

## 2.1 問題ドメインのモデリング

## 2.2 実装詳細の隠蔽

## 2.3 最小限の完全性

## 2.4 使いやすさ

## 2.5 疎結合
優れたAPIは結合度が低く凝集度が高い. コンポーネント間の結合を可能な限り低く保とう.

疎結合：
- クラスのメソッドの数, メソッドあたりの引数が少なければ, それを呼び出すコンポーネントとの結合度は低い.
- メソッド内部でグローバル変数を書き換えるのは, 結合度が上がる.
- クラスの継承は, クラスの合成(コンポジション)よりも結合度が高い. サブクラスがベースクラスのprotectedメンバにアクセスできるから.
- メソッドのシグネチャを変えた時に, このメソッドに依存するすべてのコードの変更が局所的に行えるならば, 結合度は低い.

## 2.6 安定性、文書化、テスト
- 適切にバージョン管理されて後方互換性が保たれていること.
- 十分に文書化されていれば, ユーザーがエラー条件やベストプラクティスなどについての明確な情報が得られる.
- 自動テストがあれば既存のユースケースを壊さずにAPIを変更できる.
# 第3章 パタン
[Design Patterns]の方にもっと詳細があるので、一旦略
## 3.1 Pimpl Idiom

## 3.2 Singleton

## 3.3 Factory Method

## 3.4 APIのラッピングパラン

## 3.5 Observerパタン

# 第4章 デザイン

## 4.1 優れた設計の重要性

## 4.2 機能要件の収集

## 4.3 ユーザケースの作成

## 4.4 API設計の構成要素

## 4.5 アーキテクチャの設計

## 4.6 クラスの設計

## 4.7 関数の設計

# 第5章 スタイル
## 5.1 Flat C API
## 5.2 オブジェクト指向のC++ API
## 5.3 テンプレートベースのAPI
## 5.4 データ駆動型API

# 第6章 C++の使用法
## 6.1 namespace
## 6.2 constructor and operator
## 6.3 const コレクトネス
## 6.4 Template
## 6.5 operator overloading
## 6.6 関数のパラメータ
## 6.7 定数の#defineを避ける
## 6.8 friendの使用を避ける
## 6.9 シンボルのエクスポート
## 6.10 Coding規約

# 第7章 パフォーマンス
## 7.1 const参照で入力引数を渡す
## 7.2 #includeの依存関係を最小限に
## 7.3 定数の宣言
## 7.4 初期化リスト
## 7.5 メモリの最適化
## 7.6 不必要なinline化はしない
## 7.7 書き込み時コピー
## 7.8 複数要素への反復
## 7.9 パフォーマンスの解析

# 第8章 バージョン管理
## 8.1 バージョン番号
## 8.2 ソフトウェアの分岐戦略
## 8.3 APIのlifecycle
## 8.4 互換性のレベル
## 8.5 後方互換性を確保する方法
## 8.6 APIレビュー


# 第9章 ドキュメント
## 9.1 ドキュメントを作成する理由
## 9.2 ドキュメントの種類
## 9.3 ドキュメントの使いやすさ
## 9.4 Doxygenの使用法


# 第10章 テスティング
## 10.1 テストを記述する理由
## 10.2 APIテストの種類
## 10.3 優れたテストの記述法
## 10.4 テスト可能なコードの記述
## 10.5 自動テストツール



# 第11章 スクリプト記述
## 11.1 スクリプトバイディングの追加
## 11.2 スクリプトバイディングのテクノロジー
## 11.3 Boost pythonによるpythonバイディングの追加
## 11.4 SWIGによるRubyバイディングの追加



# 第12章 拡張性
## 12.1 プラグインによる拡張
## 12.2 継承による拡張
## 12.3 テンプレートによる拡張
